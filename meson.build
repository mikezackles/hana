project('hana', 'cpp', default_options : ['cpp_std=c++14'])

hana_includes = include_directories('include')
hana_test_includes = include_directories('test/_include')

base_tests = [
  ['assert', 'commas']
, ['assert', 'constant']
, ['assert', 'constexpr']
, ['assert', 'flexible']
, ['assert', 'lambdas']
, ['assert', 'runtime']
, ['basic_tuple', 'cnstr.copy']
, ['basic_tuple', 'construct']
, ['basic_tuple', 'laws']
, ['basic_tuple', 'length']
, ['basic_tuple', 'make']
, ['basic_tuple', 'unpack']
, ['basic_tuple', 'auto', 'all_of']
, ['basic_tuple', 'auto', 'any_of']
, ['basic_tuple', 'auto', 'at']
, ['basic_tuple', 'auto', 'cartesian_product']
, ['basic_tuple', 'auto', 'drop_back']
, ['basic_tuple', 'auto', 'drop_front']
, ['basic_tuple', 'auto', 'drop_while']
, ['basic_tuple', 'auto', 'for_each']
, ['basic_tuple', 'auto', 'group']
, ['basic_tuple', 'auto', 'index_if']
, ['basic_tuple', 'auto', 'insert']
, ['basic_tuple', 'auto', 'insert_range']
, ['basic_tuple', 'auto', 'intersperse']
, ['basic_tuple', 'auto', 'is_empty']
, ['basic_tuple', 'auto', 'lexicographical_compare']
, ['basic_tuple', 'auto', 'none_of']
, ['basic_tuple', 'auto', 'partition']
, ['basic_tuple', 'auto', 'permutations']
, ['basic_tuple', 'auto', 'remove_at']
, ['basic_tuple', 'auto', 'remove_range']
, ['basic_tuple', 'auto', 'reverse']
, ['basic_tuple', 'auto', 'scans']
, ['basic_tuple', 'auto', 'slice']
, ['basic_tuple', 'auto', 'sort']
, ['basic_tuple', 'auto', 'span']
, ['basic_tuple', 'auto', 'take_back']
, ['basic_tuple', 'auto', 'take_front']
, ['basic_tuple', 'auto', 'take_while']
, ['basic_tuple', 'auto', 'transform']
, ['basic_tuple', 'auto', 'unfolds']
, ['basic_tuple', 'auto', 'unique']
, ['basic_tuple', 'auto', 'zips']
, ['concept', 'integral_constant']
, ['concept', 'constant', 'arithmetic']
, ['concept', 'constant', 'comparable']
, ['concept', 'constant', 'laws']
, ['concept', 'constant', 'logical']
, ['concept', 'constant', 'mcd']
, ['concept', 'constant', 'orderable']
, ['concept', 'sequence', 'iterable']
, ['concept', 'sequence', 'monad']
, ['concept', 'sequence', 'monad_plus']
, ['concept', 'sequence', 'orderable']
, ['concept', 'sequence', 'searchable']
, ['concept', 'sequence', 'sequence']
, ['concept', 'struct', 'any_of']
, ['concept', 'struct', 'at_key']
, ['concept', 'struct', 'equal']
, ['concept', 'struct', 'find_if']
, ['concept', 'struct', 'fold_left']
, ['concept', 'struct', 'fold_right']
, ['concept', 'struct', 'keys']
, ['concept', 'struct', 'laws']
, ['concept', 'struct', 'macro.adapt_adt']
, ['concept', 'struct', 'macro.adapt_struct']
, ['concept', 'struct', 'macro.define_struct']
, ['concept', 'struct', 'member_function']
, ['concept', 'struct', 'members']
, ['concept', 'struct', 'unpack']
, ['core', 'common']
, ['core', 'default']
, ['core', 'is_a']
, ['core', 'is_embedded']
, ['core', 'make']
, ['core', 'tag_of']
, ['core', 'to']
, ['core', 'when']
, ['detail', 'algorithm']
, ['detail', 'any_of']
, ['detail', 'create']
, ['detail', 'decay']
, ['detail', 'fast_and']
, ['detail', 'first_unsatisfied_index']
, ['detail', 'has_duplicates']
, ['detail', 'preprocessor']
, ['detail', 'type_at']
, ['detail', 'type_foldl1']
, ['detail', 'type_foldr1']
, ['detail', 'unpack_flatten']
, ['detail', 'canonical_constant', 'laws']
, ['detail', 'variadic', 'at']
, ['detail', 'variadic', 'drop_into']
, ['detail', 'variadic', 'foldl1']
, ['detail', 'variadic', 'foldr1']
, ['detail', 'variadic', 'reverse_apply']
, ['detail', 'variadic', 'split_at']
, ['detail', 'variadic', 'take']
, ['experimental', 'types', 'at']
, ['experimental', 'types', 'contains']
, ['experimental', 'types', 'drop_front']
, ['experimental', 'types', 'equal']
, ['experimental', 'types', 'is_empty']
, ['experimental', 'types', 'transform']
, ['experimental', 'types', 'unpack']
, ['experimental', 'view', 'empty', 'is_empty']
, ['experimental', 'view', 'empty', 'length']
, ['experimental', 'view', 'empty', 'unpack']
, ['experimental', 'view', 'joined', 'at']
, ['experimental', 'view', 'joined', 'is_empty']
, ['experimental', 'view', 'joined', 'length']
, ['experimental', 'view', 'joined', 'unpack']
, ['experimental', 'view', 'single', 'at']
, ['experimental', 'view', 'single', 'is_empty']
, ['experimental', 'view', 'single', 'length']
, ['experimental', 'view', 'single', 'unpack']
, ['experimental', 'view', 'sliced', 'at']
, ['experimental', 'view', 'sliced', 'is_empty']
, ['experimental', 'view', 'sliced', 'length']
, ['experimental', 'view', 'sliced', 'unpack']
, ['experimental', 'view', 'transformed', 'ap']
, ['experimental', 'view', 'transformed', 'at']
, ['experimental', 'view', 'transformed', 'drop_front']
, ['experimental', 'view', 'transformed', 'equal']
, ['experimental', 'view', 'transformed', 'is_empty']
, ['experimental', 'view', 'transformed', 'laziness']
, ['experimental', 'view', 'transformed', 'length']
, ['experimental', 'view', 'transformed', 'less']
, ['experimental', 'view', 'transformed', 'transform']
, ['experimental', 'view', 'transformed', 'unpack']
, ['ext', 'std', 'vector']
, ['ext', 'std', 'array', 'at']
, ['ext', 'std', 'array', 'comparable']
, ['ext', 'std', 'array', 'foldable']
, ['ext', 'std', 'array', 'issue_304']
, ['ext', 'std', 'array', 'iterable']
, ['ext', 'std', 'array', 'orderable']
, ['ext', 'std', 'array', 'searchable']
, ['ext', 'std', 'bugs', 'libcxx_19616']
, ['ext', 'std', 'bugs', 'libcxx_22806']
, ['ext', 'std', 'integer_sequence', 'drop_front_exactly']
, ['ext', 'std', 'integer_sequence', 'equal']
, ['ext', 'std', 'integer_sequence', 'find_if']
, ['ext', 'std', 'integer_sequence', 'front']
, ['ext', 'std', 'integer_sequence', 'is_empty']
, ['ext', 'std', 'integer_sequence', 'laws']
, ['ext', 'std', 'integer_sequence', 'unpack']
, ['ext', 'std', 'integral_constant', 'arithmetic']
, ['ext', 'std', 'integral_constant', 'comparable']
, ['ext', 'std', 'integral_constant', 'constant']
, ['ext', 'std', 'integral_constant', 'interop']
, ['ext', 'std', 'integral_constant', 'logical']
, ['ext', 'std', 'integral_constant', 'orderable']
, ['ext', 'std', 'integral_constant', 'tag']
, ['ext', 'std', 'pair', 'first_second']
, ['ext', 'std', 'pair', 'issue_90']
, ['ext', 'std', 'pair', 'laws']
, ['ext', 'std', 'pair', 'make']
, ['ext', 'std', 'ratio', 'div']
, ['ext', 'std', 'ratio', 'equal']
, ['ext', 'std', 'ratio', 'laws']
, ['ext', 'std', 'ratio', 'less']
, ['ext', 'std', 'ratio', 'minus']
, ['ext', 'std', 'ratio', 'mod']
, ['ext', 'std', 'ratio', 'mult']
, ['ext', 'std', 'ratio', 'one']
, ['ext', 'std', 'ratio', 'plus']
, ['ext', 'std', 'ratio', 'to']
, ['ext', 'std', 'ratio', 'zero']
, ['ext', 'std', 'tuple', 'issue_90']
, ['ext', 'std', 'tuple', 'laws']
, ['ext', 'std', 'tuple', 'laws.functor']
, ['ext', 'std', 'tuple', 'laws.searchable']
, ['ext', 'std', 'tuple', 'auto', 'all_of']
, ['ext', 'std', 'tuple', 'auto', 'any_of']
, ['ext', 'std', 'tuple', 'auto', 'at']
, ['ext', 'std', 'tuple', 'auto', 'cartesian_product']
, ['ext', 'std', 'tuple', 'auto', 'drop_back']
, ['ext', 'std', 'tuple', 'auto', 'drop_front']
, ['ext', 'std', 'tuple', 'auto', 'drop_while']
, ['ext', 'std', 'tuple', 'auto', 'for_each']
, ['ext', 'std', 'tuple', 'auto', 'group']
, ['ext', 'std', 'tuple', 'auto', 'index_if']
, ['ext', 'std', 'tuple', 'auto', 'insert']
, ['ext', 'std', 'tuple', 'auto', 'insert_range']
, ['ext', 'std', 'tuple', 'auto', 'intersperse']
, ['ext', 'std', 'tuple', 'auto', 'is_empty']
, ['ext', 'std', 'tuple', 'auto', 'lexicographical_compare']
, ['ext', 'std', 'tuple', 'auto', 'none_of']
, ['ext', 'std', 'tuple', 'auto', 'partition']
, ['ext', 'std', 'tuple', 'auto', 'permutations']
, ['ext', 'std', 'tuple', 'auto', 'remove_at']
, ['ext', 'std', 'tuple', 'auto', 'remove_range']
, ['ext', 'std', 'tuple', 'auto', 'reverse']
, ['ext', 'std', 'tuple', 'auto', 'scans']
, ['ext', 'std', 'tuple', 'auto', 'slice']
, ['ext', 'std', 'tuple', 'auto', 'sort']
, ['ext', 'std', 'tuple', 'auto', 'span']
, ['ext', 'std', 'tuple', 'auto', 'take_back']
, ['ext', 'std', 'tuple', 'auto', 'take_front']
, ['ext', 'std', 'tuple', 'auto', 'take_while']
, ['ext', 'std', 'tuple', 'auto', 'transform']
, ['ext', 'std', 'tuple', 'auto', 'unfolds']
, ['ext', 'std', 'tuple', 'auto', 'unique']
, ['ext', 'std', 'tuple', 'auto', 'zips']
, ['fold_left', 'ref']
, ['fold_right', 'ref']
, ['foldable', 'fold_left_mcd', 'iterable']
, ['foldable', 'fold_left_mcd', 'monad']
, ['foldable', 'fold_left_mcd', 'monad_plus']
, ['foldable', 'fold_left_mcd', 'orderable']
, ['foldable', 'fold_left_mcd', 'searchable']
, ['foldable', 'fold_left_mcd', 'sequence']
, ['foldable', 'iterable_mcd', 'iterable']
, ['foldable', 'iterable_mcd', 'monad']
, ['foldable', 'iterable_mcd', 'monad_plus']
, ['foldable', 'iterable_mcd', 'orderable']
, ['foldable', 'iterable_mcd', 'searchable']
, ['foldable', 'iterable_mcd', 'sequence']
, ['foldable', 'unpack_mcd', 'iterable']
, ['foldable', 'unpack_mcd', 'monad']
, ['foldable', 'unpack_mcd', 'monad_plus']
, ['foldable', 'unpack_mcd', 'orderable']
, ['foldable', 'unpack_mcd', 'searchable']
, ['foldable', 'unpack_mcd', 'sequence']
, ['functional', 'apply']
, ['functional', 'capture']
, ['functional', 'demux']
, ['functional', 'fix']
, ['functional', 'iterate']
, ['functional', 'lockstep']
, ['functional', 'overload_linearly']
, ['functional', 'partial']
, ['functional', 'placeholder']
, ['functional', 'reverse_partial']
, ['identity', 'applicative.full_mcd']
, ['identity', 'applicative.monad_mcd']
, ['identity', 'functor.adjust_mcd']
, ['identity', 'functor.transform_mcd']
, ['identity', 'monad.chain_mcd']
, ['identity', 'monad.flatten_mcd']
, ['if_', 'non_copyable']
, ['integral_constant', 'arithmetic']
, ['integral_constant', 'comparable']
, ['integral_constant', 'constant']
, ['integral_constant', 'constexpr_init']
, ['integral_constant', 'hash']
, ['integral_constant', 'hashable']
, ['integral_constant', 'logical']
, ['integral_constant', 'operators']
, ['integral_constant', 'orderable']
, ['integral_constant', 'std_api']
, ['integral_constant', 'tag']
, ['integral_constant', 'times']
, ['integral_constant', 'udl']
, ['issues', 'clang_20046']
, ['issues', 'github_112']
, ['issues', 'github_113']
, ['issues', 'github_149']
, ['issues', 'github_15']
, ['issues', 'github_165']
, ['issues', 'github_221']
, ['issues', 'github_234']
, ['issues', 'github_252']
, ['issues', 'github_260']
, ['issues', 'github_266']
, ['issues', 'github_269']
, ['issues', 'github_297']
, ['issues', 'github_31']
, ['issues', 'github_331']
, ['issues', 'github_91']
, ['map', 'any_of']
, ['map', 'assign.copy']
, ['map', 'assign.move']
, ['map', 'at_key.collisions']
, ['map', 'at_key']
, ['map', 'at_key.ref']
, ['map', 'at_key.stackoverflow']
, ['map', 'cnstr.copy']
, ['map', 'cnstr.default']
, ['map', 'cnstr.move']
, ['map', 'cnstr.trap']
, ['map', 'cnstr.variadic']
, ['map', 'contains']
, ['map', 'difference']
, ['map', 'equal']
, ['map', 'erase_key']
, ['map', 'find_if']
, ['map', 'fold_left']
, ['map', 'fold_right']
, ['map', 'insert']
, ['map', 'intersection']
, ['map', 'is_subset']
, ['map', 'keys']
, ['map', 'laws']
, ['map', 'map']
, ['map', 'symmetric_difference']
, ['map', 'to']
, ['map', 'union']
, ['map', 'unpack']
, ['map', 'values']
, ['numeric', 'minus_mcd']
, ['numeric', 'negate_mcd']
, ['optional', 'any_of']
, ['optional', 'ap']
, ['optional', 'chain']
, ['optional', 'concat']
, ['optional', 'copy.trap_construct']
, ['optional', 'empty']
, ['optional', 'equal']
, ['optional', 'find_if']
, ['optional', 'flatten']
, ['optional', 'fold_left']
, ['optional', 'fold_right']
, ['optional', 'is_just']
, ['optional', 'is_nothing']
, ['optional', 'laws']
, ['optional', 'less']
, ['optional', 'lift']
, ['optional', 'make']
, ['optional', 'maybe']
, ['optional', 'nested_type']
, ['optional', 'operator_arrow']
, ['optional', 'operator_deref']
, ['optional', 'representation']
, ['optional', 'sfinae']
, ['optional', 'transform']
, ['optional', 'unpack']
, ['optional', 'value']
, ['optional', 'value_or']
, ['pair', 'assign.copy']
, ['pair', 'assign.move']
, ['pair', 'cnstr.default']
, ['pair', 'cnstr.copy']
, ['pair', 'cnstr.memberwise']
, ['pair', 'cnstr.move']
, ['pair', 'comparable']
, ['pair', 'foldable']
, ['pair', 'issue_90']
, ['pair', 'make']
, ['pair', 'orderable']
, ['pair', 'product']
, ['pair', 'tag_of']
, ['range', 'at']
, ['range', 'back']
, ['range', 'contains']
, ['range', 'drop_front']
, ['range', 'drop_front_exactly']
, ['range', 'equal']
, ['range', 'find']
, ['range', 'front']
, ['range', 'is_empty']
, ['range', 'laws']
, ['range', 'length']
, ['range', 'make']
, ['range', 'maximum']
, ['range', 'minimum']
, ['range', 'product']
, ['range', 'range_c']
, ['range', 'sum']
, ['range', 'unpack']
, ['set', 'any_of']
, ['set', 'cnstr.copy']
, ['set', 'cnstr.default']
, ['set', 'cnstr.move']
, ['set', 'cnstr.trap']
, ['set', 'difference']
, ['set', 'equal']
, ['set', 'erase_key']
, ['set', 'find_if']
, ['set', 'insert']
, ['set', 'intersection']
, ['set', 'is_subset']
, ['set', 'laws']
, ['set', 'make']
, ['set', 'symmetric_difference']
, ['set', 'to']
, ['set', 'union']
, ['set', 'unpack']
, ['string', 'any_of']
, ['string', 'at']
, ['string', 'c_str']
, ['string', 'cnstr.copy']
, ['string', 'cnstr.default']
, ['string', 'contains']
, ['string', 'drop_front_exactly']
, ['string', 'equal']
, ['string', 'find']
, ['string', 'find_if']
, ['string', 'front']
, ['string', 'hash']
, ['string', 'is_empty']
, ['string', 'laws']
, ['string', 'length']
, ['string', 'less']
, ['string', 'macro']
, ['string', 'make']
, ['string', 'plus']
, ['string', 'to']
, ['string', 'udl']
, ['string', 'unpack']
, ['string', 'zero']
, ['tuple', 'any_of.clang_ice']
, ['tuple', 'assign.convert_copy']
, ['tuple', 'assign.convert_move']
, ['tuple', 'assign.copy']
, ['tuple', 'assign.move']
, ['tuple', 'at.const']
, ['tuple', 'at.non_const']
, ['tuple', 'at.rv']
, ['tuple', 'cnstr.convert_copy']
, ['tuple', 'cnstr.convert_move']
, ['tuple', 'cnstr.copy']
, ['tuple', 'cnstr.default']
, ['tuple', 'cnstr.move']
, ['tuple', 'cnstr.nested']
, ['tuple', 'cnstr.trap']
, ['tuple', 'cnstr.variadic_copy']
, ['tuple', 'cnstr.variadic_forward']
, ['tuple', 'hold_refs']
, ['tuple', 'issue_90']
, ['tuple', 'laws']
, ['tuple', 'laws.functor']
, ['tuple', 'laws.searchable']
, ['tuple', 'move_only']
, ['tuple', 'pair_interop']
, ['tuple', 'smart_ptr']
, ['tuple', 'special.drop_front_exactly']
, ['tuple', 'special.empty']
, ['tuple', 'special.equal']
, ['tuple', 'special.fill']
, ['tuple', 'special.fold_left']
, ['tuple', 'special.fold_right']
, ['tuple', 'special.front']
, ['tuple', 'special.is_empty']
, ['tuple', 'special.prepend']
, ['tuple', 'special.transform']
, ['tuple', 'to']
, ['tuple', 'unpack']
, ['tuple', 'usability_of_types']
, ['tuple', 'auto', 'all_of']
, ['tuple', 'auto', 'any_of']
, ['tuple', 'auto', 'at']
, ['tuple', 'auto', 'cartesian_product']
, ['tuple', 'auto', 'drop_back']
, ['tuple', 'auto', 'drop_front']
, ['tuple', 'auto', 'drop_while']
, ['tuple', 'auto', 'for_each']
, ['tuple', 'auto', 'group']
, ['tuple', 'auto', 'index_if']
, ['tuple', 'auto', 'insert']
, ['tuple', 'auto', 'insert_range']
, ['tuple', 'auto', 'intersperse']
, ['tuple', 'auto', 'is_empty']
, ['tuple', 'auto', 'lexicographical_compare']
, ['tuple', 'auto', 'none_of']
, ['tuple', 'auto', 'partition']
, ['tuple', 'auto', 'permutations']
, ['tuple', 'auto', 'remove_at']
, ['tuple', 'auto', 'remove_range']
, ['tuple', 'auto', 'reverse']
, ['tuple', 'auto', 'scans']
, ['tuple', 'auto', 'slice']
, ['tuple', 'auto', 'sort']
, ['tuple', 'auto', 'span']
, ['tuple', 'auto', 'take_back']
, ['tuple', 'auto', 'take_front']
, ['tuple', 'auto', 'take_while']
, ['tuple', 'auto', 'transform']
, ['tuple', 'auto', 'unfolds']
, ['tuple', 'auto', 'unique']
, ['tuple', 'auto', 'zips']
, ['type', 'adl']
, ['type', 'alignof']
, ['type', 'decltype']
, ['type', 'equal']
, ['type', 'hash']
, ['type', 'inherit_basic_type']
, ['type', 'integral']
, ['type', 'is_valid']
, ['type', 'laws']
, ['type', 'make']
, ['type', 'metafunction']
, ['type', 'metafunction_class']
, ['type', 'nested_type']
, ['type', 'sizeof']
, ['type', 'template']
, ['type', 'traits']
, ['type', 'typeid']
, ['type', 'unary_plus']
, ['builtin_array']
, ['comparable']
, ['euclidean_ring']
, ['functional']
, ['group']
, ['index_if']
, ['lazy']
, ['logical']
, ['minimal_product']
, ['monoid']
, ['orderable']
, ['repeat']
, ['ring']
, ['searchable']
]

tests_requiring_boost = [
  ['experimental', 'printable', 'map']
, ['experimental', 'printable', 'metafunction']
, ['experimental', 'printable', 'optional']
, ['experimental', 'printable', 'pair']
, ['experimental', 'printable', 'set']
, ['experimental', 'printable', 'string']
, ['experimental', 'printable', 'tuple']
, ['experimental', 'printable', 'type']
, ['ext', 'boost', 'fusion', 'deque']
, ['ext', 'boost', 'fusion', 'list']
, ['ext', 'boost', 'fusion', 'tuple']
, ['ext', 'boost', 'fusion', 'vector']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'all_of']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'any_of']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'at']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'cartesian_product']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'drop_back']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'drop_front']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'drop_while']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'for_each']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'group']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'index_if']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'insert']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'insert_range']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'intersperse']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'is_empty']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'lexicographical_compare']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'none_of']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'partition']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'permutations']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'remove_at']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'remove_range']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'reverse']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'scans']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'slice']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'sort']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'span']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'take_back']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'take_front']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'take_while']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'transform']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'unfolds']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'unique']
, ['ext', 'boost', 'fusion', 'deque', 'auto', 'zips']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'all_of']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'any_of']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'at']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'cartesian_product.broken']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'drop_back']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'drop_front']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'drop_while']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'for_each']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'group']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'index_if']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'insert']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'insert_range']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'intersperse']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'is_empty']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'lexicographical_compare']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'none_of']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'partition']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'permutations.broken']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'remove_at']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'remove_range']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'reverse']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'scans']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'slice']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'sort']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'span']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'take_back']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'take_front']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'take_while']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'transform']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'unfolds']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'unique']
, ['ext', 'boost', 'fusion', 'list', 'auto', 'zips.broken']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'all_of']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'any_of']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'at']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'cartesian_product.broken']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'drop_back']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'drop_front']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'drop_while']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'for_each']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'group']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'index_if']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'insert']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'insert_range']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'intersperse']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'is_empty']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'lexicographical_compare']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'none_of']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'partition']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'permutations.broken']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'remove_at']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'remove_range']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'reverse']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'scans']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'slice']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'sort']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'span']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'take_back']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'take_front']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'take_while']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'transform']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'unfolds']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'unique']
, ['ext', 'boost', 'fusion', 'tuple', 'auto', 'zips.broken']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'all_of']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'any_of']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'at']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'cartesian_product']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'drop_back']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'drop_front']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'drop_while']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'for_each']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'group']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'index_if']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'insert']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'insert_range']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'intersperse']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'is_empty']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'lexicographical_compare']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'none_of']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'partition']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'permutations']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'remove_at']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'remove_range']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'reverse']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'scans']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'slice']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'sort']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'span']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'take_back']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'take_front']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'take_while']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'transform']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'unfolds']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'unique']
, ['ext', 'boost', 'fusion', 'vector', 'auto', 'zips']
, ['ext', 'boost', 'mpl', 'integral_c', 'arithmetic']
, ['ext', 'boost', 'mpl', 'integral_c', 'comparable']
, ['ext', 'boost', 'mpl', 'integral_c', 'constant']
, ['ext', 'boost', 'mpl', 'integral_c', 'interop']
, ['ext', 'boost', 'mpl', 'integral_c', 'logical']
, ['ext', 'boost', 'mpl', 'integral_c', 'orderable']
, ['ext', 'boost', 'mpl', 'integral_c', 'tag']
, ['ext', 'boost', 'mpl', 'list', 'comparable']
, ['ext', 'boost', 'mpl', 'list', 'foldable']
, ['ext', 'boost', 'mpl', 'list', 'iterable']
, ['ext', 'boost', 'mpl', 'list', 'searchable']
, ['ext', 'boost', 'mpl', 'list', 'tag']
, ['ext', 'boost', 'mpl', 'list', 'to']
, ['ext', 'boost', 'mpl', 'vector', 'comparable']
, ['ext', 'boost', 'mpl', 'vector', 'foldable']
, ['ext', 'boost', 'mpl', 'vector', 'iterable']
, ['ext', 'boost', 'mpl', 'vector', 'searchable']
, ['ext', 'boost', 'mpl', 'vector', 'tag']
, ['ext', 'boost', 'mpl', 'vector', 'to']
, ['ext', 'boost', 'tuple', 'iterable']
, ['ext', 'boost', 'tuple', 'monad']
, ['ext', 'boost', 'tuple', 'monad_plus']
, ['ext', 'boost', 'tuple', 'orderable']
, ['ext', 'boost', 'tuple', 'searchable']
, ['ext', 'boost', 'tuple', 'tag_of']
, ['ext', 'boost', 'tuple', 'auto', 'all_of']
, ['ext', 'boost', 'tuple', 'auto', 'any_of']
, ['ext', 'boost', 'tuple', 'auto', 'at']
, ['ext', 'boost', 'tuple', 'auto', 'cartesian_product']
, ['ext', 'boost', 'tuple', 'auto', 'drop_back']
, ['ext', 'boost', 'tuple', 'auto', 'drop_front']
, ['ext', 'boost', 'tuple', 'auto', 'drop_while']
, ['ext', 'boost', 'tuple', 'auto', 'for_each']
, ['ext', 'boost', 'tuple', 'auto', 'group']
, ['ext', 'boost', 'tuple', 'auto', 'index_if']
, ['ext', 'boost', 'tuple', 'auto', 'insert']
, ['ext', 'boost', 'tuple', 'auto', 'insert_range']
, ['ext', 'boost', 'tuple', 'auto', 'intersperse.broken']
, ['ext', 'boost', 'tuple', 'auto', 'is_empty']
, ['ext', 'boost', 'tuple', 'auto', 'lexicographical_compare']
, ['ext', 'boost', 'tuple', 'auto', 'none_of']
, ['ext', 'boost', 'tuple', 'auto', 'partition']
, ['ext', 'boost', 'tuple', 'auto', 'permutations.broken']
, ['ext', 'boost', 'tuple', 'auto', 'remove_at']
, ['ext', 'boost', 'tuple', 'auto', 'remove_range']
, ['ext', 'boost', 'tuple', 'auto', 'reverse']
, ['ext', 'boost', 'tuple', 'auto', 'scans']
, ['ext', 'boost', 'tuple', 'auto', 'slice']
, ['ext', 'boost', 'tuple', 'auto', 'sort']
, ['ext', 'boost', 'tuple', 'auto', 'span']
, ['ext', 'boost', 'tuple', 'auto', 'take_back']
, ['ext', 'boost', 'tuple', 'auto', 'take_front.broken']
, ['ext', 'boost', 'tuple', 'auto', 'take_while']
, ['ext', 'boost', 'tuple', 'auto', 'transform']
, ['ext', 'boost', 'tuple', 'auto', 'unfolds']
, ['ext', 'boost', 'tuple', 'auto', 'unique']
, ['ext', 'boost', 'tuple', 'auto', 'zips']
]

test_type_name = [
  ['experimental', 'type_name']
]

tests_broken_on_clang_msvc = [
  ['detail', 'ebo']
, ['issues', 'github_202']
, ['pair', 'empty_storage']
, ['tuple', 'empty_member']
]

odr_violation_sources = [
  ['issues', 'github_75', 'tu1']
, ['issues', 'github_75', 'tu2']
]

# Ensure that all .cpp files in the test directory have been built
all_paths = base_tests
all_paths += tests_requiring_boost
all_paths += test_type_name
all_paths += tests_broken_on_clang_msvc
all_paths += odr_violation_sources
all_sources = []
foreach path : all_paths
  all_sources += join_paths([meson.current_source_dir(), 'test'] + path)+'.cpp'
endforeach
python = find_program('python', 'python3', 'python2')
if python.found()
  test(
    'ensure all tests built'
  , files(python.path())
  , args: files('all_tests_built.py') + all_sources
  )
endif

tests = base_tests

boost = dependency('boost', version : '>=1.59', required : false)
if boost.found()
  tests += tests_requiring_boost
endif

cpp_compiler = meson.get_compiler('cpp')

# Add relevant flags
maybe_cpp_test_flags = [
  '-fdiagnostics-color'
, '-ftemplate-backtrace-limit=0'
, '-pedantic'
, '-Wall'
, '-Werror'
, '-Wextra'
, '-Wno-unused-local-typedefs'
, '-Wno-unused-but-set-variable' # differs from CMake build!
, '-Wwrite-strings'
]
cpp_test_flags = []
foreach flag : maybe_cpp_test_flags
  if cpp_compiler.has_argument(flag)
    cpp_test_flags += flag
  endif
endforeach

if (
  (
    build_machine.system() == 'darwin'
    and
    cpp_compiler.get_id() == 'clang'
    and
    cpp_compiler.version().version_compare('>=7.0')
  )
  or
  (
    cpp_compiler.get_id() == 'clang'
    and
    cpp_compiler.version().version_compare('>=3.6')
  )
)
  tests += test_type_name
endif

# On Windows, Clang-cl emulates a MSVC bug that causes EBO not to be applied
# properly. We disable the tests that check for EBO.
if not (
  build_machine.system() == 'windows'
  and
  cpp_compiler.get_id() == 'clang'
)
  tests += tests_broken_on_clang_msvc
endif

# Run the tests
foreach directories : tests
  all_directories = ['test'] + directories
  name = '__'.join(all_directories)
  file = join_paths(all_directories)+'.cpp'
  test(
    name
  , executable(
      name, file
    , include_directories : [hana_includes, hana_test_includes]
    , implicit_include_directories : false
    , cpp_args : cpp_test_flags
    )
  )
endforeach

# Check for ODR violations with multiple TUs/includes
odr_violation = []
foreach directories : odr_violation_sources
  odr_violation += join_paths(['test'] + directories)+'.cpp'
endforeach
test(
  'issues__github_75'
, executable(
    'issues__github_75'
  , odr_violation
  , include_directories : [hana_includes, hana_test_includes]
  , implicit_include_directories : false
  , cpp_args : cpp_test_flags
  )
)

hana = declare_dependency(include_directories : hana_includes)